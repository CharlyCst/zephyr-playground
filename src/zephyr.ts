
// This files has been generated using `package_zph.py`, do not edit.

interface IFolder {
  folders: { [folder: string]: IFolder };
  files: { [file: string]: IFile };
}

interface IFile {
  code: string;
  fileName: string;
  fileId: number;
  isAsm: boolean;
}

export const modules: { [module: string]: IFolder } = JSON.parse(`
{"std": {"folders": {"r": {"folders": {}, "files": {"wasi": {"fileName": "wasi", "fileId": 3, "isAsm": false, "code": "/// Wasi runtime\\nstandalone runtime module wasi\\n\\nuse core.str\\nuse core.mem\\n\\n// Tested on Wasmtime 0.15.0\\nfrom wasi_unstable import {\\n    pub fun fd_write(fd: i32, iovs: i32, iovs_len: i32, nwritten: i32): i32\\n}\\n\\n/// Print a string to stdout.\\npub fun print(message: str.Str) {\\n    let iov = mem.malloc(12)\\n    mem.set_i32(iov, message.start)\\n    mem.set_i32(iov + 4, message.len)\\n    fd_write(1, iov, 1, iov + 8)\\n    mem.free(iov)\\n}\\n"}, "r": {"fileName": "r", "fileId": 4, "isAsm": false, "code": "/// Runtime modules\\n///\\n/// This module hosts a collection of runtime modules for well known platforms, such as Wasi.\\nmodule r\\n\\n"}}}}, "files": {"std": {"fileName": "std", "fileId": 2, "isAsm": false, "code": "/// The Zephyr standard library\\nmodule std\\n\\n"}}}, "core": {"folders": {"mem": {"folders": {}, "files": {"utils": {"fileName": "utils", "fileId": 7, "isAsm": true, "code": "module mem\\n\\n/// Increases the memory size by a given number of pages and return the old\\n/// memory size, or -1 if the operation failed.\\n///\\n/// A memory page is 65536 bytes, or 64Ki bytes\\nfun memory_grow(size: i32): i32 {\\n    local.get size\\n    memory.grow\\n}\\n\\n/// Returns the size of memory in pages (65536 = 2^16 bytes).\\nfun memory_size(): i32 {\\n    memory.size\\n}\\n\\n/// Reads an i32 from memory, expects an alignment of 32 at least.\\npub fun read_i32(addr: i32): i32 {\\n    local.get addr\\n    i32.load 2 0\\n}\\n\\n/// Reads an u8 from memory, returned as an i32.\\npub fun read_u8(addr: i32): i32 {\\n    local.get addr\\n    i32.load8_u 0 0\\n}\\n\\n/// Set an i32 at the given memory address, expects an alignment of 32 at least.\\npub fun set_i32(addr: i32, val: i32) {\\n    local.get addr\\n    local.get val\\n    i32.store 2 0\\n}\\n\\npub fun set_u8(addr: i32, val: i32) {\\n    local.get addr\\n    local.get val\\n    i32.store8 0 0\\n}\\n"}, "malloc": {"fileName": "malloc", "fileId": 8, "isAsm": false, "code": "/// The malloc module handles memory management, it exposes a malloc and free\\n/// implementation.\\nmodule mem\\n\\nuse core.utils\\n\\n// The global memory allocator.\\n//\\n// Malloc is implemented using a doubly linked free list with a first fit\\n// strategy. Malloc always return a block with an aligment of 8 bytes.\\n// Coalescing is done after the free operation.\\n//\\n// Each block is composed of:\\n//   - a 4 bytes header\\n//   - a 4 bytes pointer to the next block\\n//   - a 4 bytes pointer to the previous block\\n//   - a 4 bytes footer\\n//\\n//   0      4      8      10        n-4     n\\n//\\n//   +------+------+------+----------+------+\\n//   |      |      |      |          |      |\\n//   |header| next | prev |   ....   |footer|\\n//   |      |      |      |          |      |\\n//   +------+------+------+----------+------+\\n//\\n//\\n// The header and the footer have the same values, they are outsize of the\\n// range seen by the user. The 31 lowest bits indicate the size, while the\\n// highest bit is a flag that is set when the block is allocated, and unset\\n// when it is freed.\\n// The size do not correspond to the size seen by the user, but to the number\\n// of bytes following the header (including the footer): the smallest valid\\n// valid takes 16 bytes in memory and thus has a size of 12 (16 - 4).\\n//\\n// Assumptions:\\n//   - The compiler ensures that at initialization read_i32(0) returns the\\n//     address of the first (and unique) free block.\\n//   - The compiler ensures that at initialization there is a fake\\n//     'allocated block' footer just before the first free block.\\n\\n/// Returns a fresh block of memory, guaranted with an alignment of at least 8.\\n///\\n/// This malloc implementation uses a single (doubly linked) free list with a\\n/// first-fit strategy.\\n/// Coalescence is done when blocks are freed.\\npub fun malloc(size: i32): i32 {\\n    let addr = read_i32(0)\\n    let target_size = get_real_block_size(size)\\n    while true {\\n        if addr == 0 {\\n            // TODO: out of memory\\n            utils.panic()\\n        }\\n        if read_i32(addr) >= target_size {\\n            let block_size = split_block(addr, target_size)\\n            remove_block(addr)\\n            let header = block_size | 0x80000000 // set the allocated bit\\n            set_i32(addr, header)                // header\\n            set_i32(addr + block_size, header)   // footer\\n            return addr + 4\\n        }\\n        addr = read_i32(addr + 4)                // go to next block\\n    }\\n    // needed for wasm stack type check...\\n    // TODO: find a (compiler) solution\\n    return 0\\n}\\n\\n/// Marks the memory as free.\\n///\\n/// This operation is the inverse of malloc, blocks freed can be re-allocated later.\\npub fun free(ptr: i32) {\\n    let addr = ptr - 4\\n    let old_root = read_i32(0)\\n    if old_root != 0 {\\n        set_i32(old_root + 8, addr)\\n    }\\n    set_i32(0, addr)\\n    set_i32(addr + 4, old_root)\\n    set_i32(addr + 8, 0)\\n    // Mark the block as free\\n    let header = read_i32(addr) ^ 0x80000000 // unset the allocated bit\\n    set_i32(addr, header)                    // header\\n    set_i32(addr + header, header)           // footer\\n    try_coalesce(addr)\\n}\\n\\n/// Computes the final size of a block, so that the next block is aligned to 8 and\\n/// there is room for at least two 4 bytes pointers and a 4 bytes footer.\\nfun get_real_block_size(size: i32): i32 {\\n    if size <= 8 {\\n        return 12\\n    }\\n    let body_size = (size + 0b111) & -0b1000\\n    return body_size + 4\\n}\\n\\n/// Tell if a block is free given its header.\\n///\\n/// A block header is composed of 31 bits for its size, while the highest bit\\n/// is a flag indicating if the block is free (0) or allocated (1).\\n/// Thus, interpreted as a signed 32 bits integer, if the header is positive\\n/// then the block is free.\\nfun is_free(header: i32): bool {\\n    return header >= 0\\n}\\n\\n/// Split a free block, if possible, and return the new size.\\n///\\n/// The minimal block size is 16:\\n///   - 4 bytes header\\n///   - 4 bytes next pointer\\n///   - 4 bytes prev pointer\\n///   - 4 bytes footer\\n///\\n/// ! The block is assumed to be free.\\nfun split_block(addr: i32, size: i32): i32 {\\n    let available_size = read_i32(addr)\\n    if available_size - size >= 16 {\\n        let new_block_addr = addr + 4 + size\\n        // update pointers\\n        set_i32(new_block_addr + 8, addr)               // prev points to addr\\n        set_i32(new_block_addr + 4, read_i32(addr + 4)) // next points to block.next\\n        set_i32(addr + 4, new_block_addr)               // block.next points to new_block\\n        // update sizes\\n        set_i32(addr, size)\\n        set_i32(new_block_addr, available_size - size - 4)\\n        return size\\n    }\\n    return available_size\\n}\\n\\n/// Removes a block from the free list.\\nfun remove_block(addr: i32) {\\n    let next = read_i32(addr + 4)\\n    let prev = read_i32(addr + 8)\\n    if next != 0 {\\n        set_i32(next + 8, prev)\\n    }\\n    if prev != 0 {\\n        set_i32(prev + 4, next)\\n    } else {\\n        set_i32(0, next)\\n    }\\n}\\n\\n/// Try to coalesce a block with the next one (following to memory layout) and\\n/// the one just before.\\n///\\n/// ! The block passed as argument is assumed to be free.\\nfun try_coalesce(addr: i32) {\\n    let size = read_i32(addr)\\n    let next_addr = addr + 4 + size\\n    if next_addr < memory_size() * 0x10000 { // end of memory\\n        let next_header = read_i32(next_addr)\\n        if is_free(next_header) {\\n            // if the block is free, the header corresponds to its size\\n            size = size + 4 + next_header\\n            remove_block(next_addr)\\n            set_i32(addr, size)        // header\\n            set_i32(addr + size, size) // footer\\n        }\\n    }\\n    let prev_footer = read_i32(addr - 4)\\n    if is_free(prev_footer) {\\n        size = size + 4 + prev_footer\\n        let prev_addr = addr - prev_footer - 4\\n        remove_block(addr)\\n        set_i32(prev_addr, size)        // header\\n        set_i32(prev_addr + size, size) // footer\\n    }\\n}\\n\\n"}}}, "str": {"folders": {}, "files": {"str": {"fileName": "str", "fileId": 9, "isAsm": false, "code": "/// Implementation of strings for Zephyr.\\nmodule str\\n\\nuse core.mem\\n\\n/// A String object, composed of a buffer holding the data and a len.\\npub struct String {\\n    len: i32,\\n    capacity: i32,\\n    buffer: i32,\\n}\\n\\n/// A String slice, a structure that doesn't own the data it points to.\\npub struct Str {\\n    len: i32,\\n    start: i32,\\n}\\n\\n/// Creates a new string.\\npub fun new_string(): String {\\n    let capacity = 12 // Arbitrary default size\\n    let buffer = mem.malloc(capacity)\\n    return String {\\n        len: 0,\\n        capacity: capacity,\\n        buffer: buffer,\\n    }\\n}\\n\\n/// Adds a character to the string.\\npub fun push_char(s: String, char: i32) {\\n    if s.capacity <= s.len {\\n        // Reallocate the buffer\\n        let new_capacity = s.capacity * 2\\n        let new_buffer = mem.malloc(new_capacity)\\n        let old_buffer = s.buffer\\n        let idx = 0\\n        while idx < s.len {\\n            let tmp = mem.read_u8(old_buffer + idx)\\n            mem.set_u8(new_buffer + idx, tmp)\\n            idx = idx + 1\\n        }\\n        mem.free(s.buffer)\\n        s.buffer = new_buffer\\n        s.capacity = new_capacity\\n    }\\n    mem.set_u8(s.buffer + s.len, char)\\n    s.len = s.len + 1\\n}\\n\\n/// Return slice from a String.\\npub fun as_str(string: String): Str {\\n    return Str {\\n        len: string.len,\\n        start: string.buffer,\\n    }\\n}\\n\\n"}}}}, "files": {"utils": {"fileName": "utils", "fileId": 5, "isAsm": true, "code": "/// Exposes utility functions\\nstandalone module utils\\n\\npub fun panic() {\\n    unreachable\\n}\\n"}, "core": {"fileName": "core", "fileId": 6, "isAsm": false, "code": "/// Core is module exposing the runtime functionnalities of Zephyr, it is\\n/// known from the compiler.\\nmodule core\\n\\nuse core.mem\\nuse core.utils\\n\\n"}}}}`)
