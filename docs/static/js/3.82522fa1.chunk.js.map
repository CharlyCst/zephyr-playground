{"version":3,"sources":["compiler/index.js","compiler/index_bg.js","../node_modules/webpack/buildin/harmony-module.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","zephyr.ts","resolver.ts","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","wasm","Uint8Array","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","isLikeNone","x","cachegetFloat64Memory0","cachegetInt32Memory0","getInt32Memory0","Int32Array","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","compile","retptr","v0","r0","r1","slice","get_memory","f","JsResolver","this","__destroy_into_raw","__wbindgen_object_drop_ref","arg0","__wbindgen_is_undefined","__wbindgen_is_null","__wbindgen_is_falsy","__wbg_resolvemodulefromjs_e376ae81e4add9e8","arg1","arg2","arg3","resolve_module_from_js","__wbg_playgroundlog_7b578c87ec6ec19b","playground_log","__wbindgen_string_new","__wbg_consolelog_c37e348eab7a6a4b","console","console_log","__wbg_get_f099d98ea7d68360","__wbg_length_450572e01ae27466","__wbg_isArray_bccef1135dd559c1","isArray","__wbg_get_0c6963cbab34fbb6","Reflect","get","apply","arguments","e","__wbindgen_number_get","Float64Array","__wbindgen_string_get","ptr0","malloc","realloc","mem","offset","code","charCodeAt","passStringToWasm0","len0","__wbindgen_boolean_get","v","__wbindgen_throw","Error","__wbindgen_memory","exports","originalModule","webpackPolyfill","Object","create","children","defineProperty","enumerable","l","i","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","configurable","writable","key","_createClass","protoProps","staticProps","prototype","modules","JSON","parse","line","kind","log_ref","lineKind","LineKind","output","input","error","root","path","files","code_ref","fileName","fileId","isAsm","isStandalone","items","split","last","pop","folder","o","allowArrayLike","it","Symbol","iterator","unsupportedIterableToArray","F","s","n","done","value","_e","err","normalCompletion","didErr","step","next","_e2","item","folders","log","keys"],"mappings":"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","file":"static/js/3.82522fa1.chunk.js","sourcesContent":["import * as wasm from \"./index_bg.wasm\";\nexport * from \"./index_bg.js\";","import { resolve_module_from_js, playground_log } from '../resolver';\nimport * as wasm from './index_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* @returns {Uint8Array | undefined}\n*/\nexport function compile() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.compile(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        let v0;\n        if (r0 !== 0) {\n            v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n        }\n        return v0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @returns {WebAssembly.Memory}\n*/\nexport function get_memory() {\n    var ret = wasm.get_memory();\n    return takeObject(ret);\n}\n\nfunction handleError(f) {\n    return function () {\n        try {\n            return f.apply(this, arguments);\n\n        } catch (e) {\n            wasm.__wbindgen_exn_store(addHeapObject(e));\n        }\n    };\n}\n/**\n*/\nexport class JsResolver {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsresolver_free(ptr);\n    }\n}\n\nexport const __wbindgen_object_drop_ref = function(arg0) {\n    takeObject(arg0);\n};\n\nexport const __wbindgen_is_undefined = function(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport const __wbindgen_is_null = function(arg0) {\n    var ret = getObject(arg0) === null;\n    return ret;\n};\n\nexport const __wbindgen_is_falsy = function(arg0) {\n    var ret = !getObject(arg0);\n    return ret;\n};\n\nexport const __wbg_resolvemodulefromjs_e376ae81e4add9e8 = function(arg0, arg1, arg2, arg3) {\n    var ret = resolve_module_from_js(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3));\n    return addHeapObject(ret);\n};\n\nexport const __wbg_playgroundlog_7b578c87ec6ec19b = function(arg0, arg1, arg2) {\n    playground_log(getStringFromWasm0(arg0, arg1), arg2 >>> 0);\n};\n\nexport const __wbindgen_string_new = function(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport const __wbg_consolelog_c37e348eab7a6a4b = function(arg0, arg1) {\n    console.console_log(getStringFromWasm0(arg0, arg1));\n};\n\nexport const __wbg_get_f099d98ea7d68360 = function(arg0, arg1) {\n    var ret = getObject(arg0)[arg1 >>> 0];\n    return addHeapObject(ret);\n};\n\nexport const __wbg_length_450572e01ae27466 = function(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n};\n\nexport const __wbg_isArray_bccef1135dd559c1 = function(arg0) {\n    var ret = Array.isArray(getObject(arg0));\n    return ret;\n};\n\nexport const __wbg_get_0c6963cbab34fbb6 = handleError(function(arg0, arg1) {\n    var ret = Reflect.get(getObject(arg0), getObject(arg1));\n    return addHeapObject(ret);\n});\n\nexport const __wbindgen_number_get = function(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nexport const __wbindgen_string_get = function(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport const __wbindgen_boolean_get = function(arg0) {\n    const v = getObject(arg0);\n    var ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nexport const __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport const __wbindgen_memory = function() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","\n// This files has been generated using `package_zph.py`, do not edit.\n\ninterface IFolder {\n  folders: { [folder: string]: IFolder };\n  files: { [file: string]: IFile };\n}\n\ninterface IFile {\n  code: string;\n  fileName: string;\n  fileId: number;\n  isAsm: boolean;\n}\n\nexport const modules: { [module: string]: IFolder } = JSON.parse(`\n{\"std\": {\"folders\": {\"r\": {\"folders\": {}, \"files\": {\"wasi\": {\"fileName\": \"wasi\", \"fileId\": 3, \"isAsm\": false, \"code\": \"/// Wasi runtime\\\\nstandalone runtime module wasi\\\\n\\\\nuse core.str\\\\nuse core.mem\\\\n\\\\n// Tested on Wasmtime 0.15.0\\\\nfrom wasi_unstable import {\\\\n    pub fun fd_write(fd: i32, iovs: i32, iovs_len: i32, nwritten: i32): i32\\\\n}\\\\n\\\\n/// Print a string to stdout.\\\\npub fun print(message: str.Str) {\\\\n    let iov = mem.malloc(12)\\\\n    mem.set_i32(iov, message.start)\\\\n    mem.set_i32(iov + 4, message.len)\\\\n    fd_write(1, iov, 1, iov + 8)\\\\n    mem.free(iov)\\\\n}\\\\n\"}, \"r\": {\"fileName\": \"r\", \"fileId\": 4, \"isAsm\": false, \"code\": \"/// Runtime modules\\\\n///\\\\n/// This module hosts a collection of runtime modules for well known platforms, such as Wasi.\\\\nmodule r\\\\n\\\\n\"}}}}, \"files\": {\"std\": {\"fileName\": \"std\", \"fileId\": 2, \"isAsm\": false, \"code\": \"/// The Zephyr standard library\\\\nmodule std\\\\n\\\\n\"}}}, \"core\": {\"folders\": {\"mem\": {\"folders\": {}, \"files\": {\"utils\": {\"fileName\": \"utils\", \"fileId\": 7, \"isAsm\": true, \"code\": \"module mem\\\\n\\\\n/// Increases the memory size by a given number of pages and return the old\\\\n/// memory size, or -1 if the operation failed.\\\\n///\\\\n/// A memory page is 65536 bytes, or 64Ki bytes\\\\nfun memory_grow(size: i32): i32 {\\\\n    local.get size\\\\n    memory.grow\\\\n}\\\\n\\\\n/// Returns the size of memory in pages (65536 = 2^16 bytes).\\\\nfun memory_size(): i32 {\\\\n    memory.size\\\\n}\\\\n\\\\n/// Reads an i32 from memory, expects an alignment of 32 at least.\\\\npub fun read_i32(addr: i32): i32 {\\\\n    local.get addr\\\\n    i32.load 2 0\\\\n}\\\\n\\\\n/// Reads an u8 from memory, returned as an i32.\\\\npub fun read_u8(addr: i32): i32 {\\\\n    local.get addr\\\\n    i32.load8_u 0 0\\\\n}\\\\n\\\\n/// Set an i32 at the given memory address, expects an alignment of 32 at least.\\\\npub fun set_i32(addr: i32, val: i32) {\\\\n    local.get addr\\\\n    local.get val\\\\n    i32.store 2 0\\\\n}\\\\n\\\\npub fun set_u8(addr: i32, val: i32) {\\\\n    local.get addr\\\\n    local.get val\\\\n    i32.store8 0 0\\\\n}\\\\n\"}, \"malloc\": {\"fileName\": \"malloc\", \"fileId\": 8, \"isAsm\": false, \"code\": \"/// The malloc module handles memory management, it exposes a malloc and free\\\\n/// implementation.\\\\nmodule mem\\\\n\\\\nuse core.utils\\\\n\\\\n// The global memory allocator.\\\\n//\\\\n// Malloc is implemented using a doubly linked free list with a first fit\\\\n// strategy. Malloc always return a block with an aligment of 8 bytes.\\\\n// Coalescing is done after the free operation.\\\\n//\\\\n// Each block is composed of:\\\\n//   - a 4 bytes header\\\\n//   - a 4 bytes pointer to the next block\\\\n//   - a 4 bytes pointer to the previous block\\\\n//   - a 4 bytes footer\\\\n//\\\\n//   0      4      8      10        n-4     n\\\\n//\\\\n//   +------+------+------+----------+------+\\\\n//   |      |      |      |          |      |\\\\n//   |header| next | prev |   ....   |footer|\\\\n//   |      |      |      |          |      |\\\\n//   +------+------+------+----------+------+\\\\n//\\\\n//\\\\n// The header and the footer have the same values, they are outsize of the\\\\n// range seen by the user. The 31 lowest bits indicate the size, while the\\\\n// highest bit is a flag that is set when the block is allocated, and unset\\\\n// when it is freed.\\\\n// The size do not correspond to the size seen by the user, but to the number\\\\n// of bytes following the header (including the footer): the smallest valid\\\\n// valid takes 16 bytes in memory and thus has a size of 12 (16 - 4).\\\\n//\\\\n// Assumptions:\\\\n//   - The compiler ensures that at initialization read_i32(0) returns the\\\\n//     address of the first (and unique) free block.\\\\n//   - The compiler ensures that at initialization there is a fake\\\\n//     'allocated block' footer just before the first free block.\\\\n\\\\n/// Returns a fresh block of memory, guaranted with an alignment of at least 8.\\\\n///\\\\n/// This malloc implementation uses a single (doubly linked) free list with a\\\\n/// first-fit strategy.\\\\n/// Coalescence is done when blocks are freed.\\\\npub fun malloc(size: i32): i32 {\\\\n    let addr = read_i32(0)\\\\n    let target_size = get_real_block_size(size)\\\\n    while true {\\\\n        if addr == 0 {\\\\n            // TODO: out of memory\\\\n            utils.panic()\\\\n        }\\\\n        if read_i32(addr) >= target_size {\\\\n            let block_size = split_block(addr, target_size)\\\\n            remove_block(addr)\\\\n            let header = block_size | 0x80000000 // set the allocated bit\\\\n            set_i32(addr, header)                // header\\\\n            set_i32(addr + block_size, header)   // footer\\\\n            return addr + 4\\\\n        }\\\\n        addr = read_i32(addr + 4)                // go to next block\\\\n    }\\\\n    // needed for wasm stack type check...\\\\n    // TODO: find a (compiler) solution\\\\n    return 0\\\\n}\\\\n\\\\n/// Marks the memory as free.\\\\n///\\\\n/// This operation is the inverse of malloc, blocks freed can be re-allocated later.\\\\npub fun free(ptr: i32) {\\\\n    let addr = ptr - 4\\\\n    let old_root = read_i32(0)\\\\n    if old_root != 0 {\\\\n        set_i32(old_root + 8, addr)\\\\n    }\\\\n    set_i32(0, addr)\\\\n    set_i32(addr + 4, old_root)\\\\n    set_i32(addr + 8, 0)\\\\n    // Mark the block as free\\\\n    let header = read_i32(addr) ^ 0x80000000 // unset the allocated bit\\\\n    set_i32(addr, header)                    // header\\\\n    set_i32(addr + header, header)           // footer\\\\n    try_coalesce(addr)\\\\n}\\\\n\\\\n/// Computes the final size of a block, so that the next block is aligned to 8 and\\\\n/// there is room for at least two 4 bytes pointers and a 4 bytes footer.\\\\nfun get_real_block_size(size: i32): i32 {\\\\n    if size <= 8 {\\\\n        return 12\\\\n    }\\\\n    let body_size = (size + 0b111) & -0b1000\\\\n    return body_size + 4\\\\n}\\\\n\\\\n/// Tell if a block is free given its header.\\\\n///\\\\n/// A block header is composed of 31 bits for its size, while the highest bit\\\\n/// is a flag indicating if the block is free (0) or allocated (1).\\\\n/// Thus, interpreted as a signed 32 bits integer, if the header is positive\\\\n/// then the block is free.\\\\nfun is_free(header: i32): bool {\\\\n    return header >= 0\\\\n}\\\\n\\\\n/// Split a free block, if possible, and return the new size.\\\\n///\\\\n/// The minimal block size is 16:\\\\n///   - 4 bytes header\\\\n///   - 4 bytes next pointer\\\\n///   - 4 bytes prev pointer\\\\n///   - 4 bytes footer\\\\n///\\\\n/// ! The block is assumed to be free.\\\\nfun split_block(addr: i32, size: i32): i32 {\\\\n    let available_size = read_i32(addr)\\\\n    if available_size - size >= 16 {\\\\n        let new_block_addr = addr + 4 + size\\\\n        // update pointers\\\\n        set_i32(new_block_addr + 8, addr)               // prev points to addr\\\\n        set_i32(new_block_addr + 4, read_i32(addr + 4)) // next points to block.next\\\\n        set_i32(addr + 4, new_block_addr)               // block.next points to new_block\\\\n        // update sizes\\\\n        set_i32(addr, size)\\\\n        set_i32(new_block_addr, available_size - size - 4)\\\\n        return size\\\\n    }\\\\n    return available_size\\\\n}\\\\n\\\\n/// Removes a block from the free list.\\\\nfun remove_block(addr: i32) {\\\\n    let next = read_i32(addr + 4)\\\\n    let prev = read_i32(addr + 8)\\\\n    if next != 0 {\\\\n        set_i32(next + 8, prev)\\\\n    }\\\\n    if prev != 0 {\\\\n        set_i32(prev + 4, next)\\\\n    } else {\\\\n        set_i32(0, next)\\\\n    }\\\\n}\\\\n\\\\n/// Try to coalesce a block with the next one (following to memory layout) and\\\\n/// the one just before.\\\\n///\\\\n/// ! The block passed as argument is assumed to be free.\\\\nfun try_coalesce(addr: i32) {\\\\n    let size = read_i32(addr)\\\\n    let next_addr = addr + 4 + size\\\\n    if next_addr < memory_size() * 0x10000 { // end of memory\\\\n        let next_header = read_i32(next_addr)\\\\n        if is_free(next_header) {\\\\n            // if the block is free, the header corresponds to its size\\\\n            size = size + 4 + next_header\\\\n            remove_block(next_addr)\\\\n            set_i32(addr, size)        // header\\\\n            set_i32(addr + size, size) // footer\\\\n        }\\\\n    }\\\\n    let prev_footer = read_i32(addr - 4)\\\\n    if is_free(prev_footer) {\\\\n        size = size + 4 + prev_footer\\\\n        let prev_addr = addr - prev_footer - 4\\\\n        remove_block(addr)\\\\n        set_i32(prev_addr, size)        // header\\\\n        set_i32(prev_addr + size, size) // footer\\\\n    }\\\\n}\\\\n\\\\n\"}}}, \"str\": {\"folders\": {}, \"files\": {\"str\": {\"fileName\": \"str\", \"fileId\": 9, \"isAsm\": false, \"code\": \"/// Implementation of strings for Zephyr.\\\\nmodule str\\\\n\\\\nuse core.mem\\\\n\\\\n/// A String object, composed of a buffer holding the data and a len.\\\\npub struct String {\\\\n    len: i32,\\\\n    capacity: i32,\\\\n    buffer: i32,\\\\n}\\\\n\\\\n/// A String slice, a structure that doesn't own the data it points to.\\\\npub struct Str {\\\\n    len: i32,\\\\n    start: i32,\\\\n}\\\\n\\\\n/// Creates a new string.\\\\npub fun new_string(): String {\\\\n    let capacity = 12 // Arbitrary default size\\\\n    let buffer = mem.malloc(capacity)\\\\n    return String {\\\\n        len: 0,\\\\n        capacity: capacity,\\\\n        buffer: buffer,\\\\n    }\\\\n}\\\\n\\\\n/// Adds a character to the string.\\\\npub fun push_char(s: String, char: i32) {\\\\n    if s.capacity <= s.len {\\\\n        // Reallocate the buffer\\\\n        let new_capacity = s.capacity * 2\\\\n        let new_buffer = mem.malloc(new_capacity)\\\\n        let old_buffer = s.buffer\\\\n        let idx = 0\\\\n        while idx < s.len {\\\\n            let tmp = mem.read_u8(old_buffer + idx)\\\\n            mem.set_u8(new_buffer + idx, tmp)\\\\n            idx = idx + 1\\\\n        }\\\\n        mem.free(s.buffer)\\\\n        s.buffer = new_buffer\\\\n        s.capacity = new_capacity\\\\n    }\\\\n    mem.set_u8(s.buffer + s.len, char)\\\\n    s.len = s.len + 1\\\\n}\\\\n\\\\n/// Return slice from a String.\\\\npub fun as_str(string: String): Str {\\\\n    return Str {\\\\n        len: string.len,\\\\n        start: string.buffer,\\\\n    }\\\\n}\\\\n\\\\n\"}}}}, \"files\": {\"utils\": {\"fileName\": \"utils\", \"fileId\": 5, \"isAsm\": true, \"code\": \"/// Exposes utility functions\\\\nstandalone module utils\\\\n\\\\npub fun panic() {\\\\n    unreachable\\\\n}\\\\n\"}, \"core\": {\"fileName\": \"core\", \"fileId\": 6, \"isAsm\": false, \"code\": \"/// Core is module exposing the runtime functionnalities of Zephyr, it is\\\\n/// known from the compiler.\\\\nmodule core\\\\n\\\\nuse core.mem\\\\nuse core.utils\\\\n\\\\n\"}}}}`)\n","import { modules } from \"./zephyr\";\nimport { code_ref, log_ref, LineKind } from \"./App\";\n\nconst VERBOSE = false;\n\ninterface IJsModule {\n  files: IJsFile[];\n  isStandalone: boolean;\n}\n\ninterface IJsFile {\n  code: string;\n  fileName: string;\n  fileId: number;\n  isAsm: boolean;\n}\n\nexport function playground_log(line: string, kind: number) {\n  if (!log_ref) {\n    return;\n  }\n\n  let lineKind = LineKind.output;\n  switch (kind) {\n    case LineKind.input:\n      lineKind = LineKind.input;\n      break;\n    case LineKind.error:\n      lineKind = LineKind.error;\n      break;\n  }\n\n  log_ref(line, lineKind);\n}\n\nexport function resolve_module_from_js(\n  root: string,\n  path: string\n): IJsModule | undefined {\n  if (VERBOSE) {\n    console.log(`Resolve ${root}/${path}`);\n  }\n\n  // Base case\n  if (root === \"playground\" && path === \"main\") {\n    return {\n      files: [{ code: code_ref, fileName: \"main\", fileId: 1, isAsm: false }],\n      isStandalone: false,\n    };\n  }\n\n  // Standard & Core library\n  const items = path.split(\"/\");\n  const last = items.pop();\n  if (last === undefined) {\n    console.log(\"Error: error in module resolution - JS side\");\n    return undefined;\n  }\n\n  let folder = modules[root];\n  if (!folder) {\n    console.log(\"Error: module does not exist - JS side\");\n    return undefined;\n  }\n\n  for (const item of items) {\n    folder = folder.folders[item];\n  }\n\n  const files = [];\n  let isStandalone = false;\n  if (folder.files[last] !== undefined) {\n    files.push(folder.files[last]);\n    isStandalone = true;\n  } else {\n    folder = folder.folders[last];\n    if (folder === undefined) {\n      console.log(\"Error: last module does not exist - JS size\");\n    }\n    for (const fileName of Object.keys(folder.files)) {\n      files.push(folder.files[fileName]);\n    }\n  }\n\n  return { files: files, isStandalone: isStandalone };\n}\n","import unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"sourceRoot":""}