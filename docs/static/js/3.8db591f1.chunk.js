(this.webpackJsonpplayground=this.webpackJsonpplayground||[]).push([[3],{23:function(e,n,t){"use strict";t.r(n);var r=t(24);t.d(n,"compile",(function(){return r.s})),t.d(n,"get_memory",(function(){return r.t})),t.d(n,"JsResolver",(function(){return r.a})),t.d(n,"__wbindgen_object_drop_ref",(function(){return r.o})),t.d(n,"__wbindgen_is_undefined",(function(){return r.l})),t.d(n,"__wbindgen_is_null",(function(){return r.k})),t.d(n,"__wbindgen_is_falsy",(function(){return r.j})),t.d(n,"__wbg_resolvemodulefromjs_e376ae81e4add9e8",(function(){return r.h})),t.d(n,"__wbg_playgroundlog_7b578c87ec6ec19b",(function(){return r.g})),t.d(n,"__wbindgen_string_new",(function(){return r.q})),t.d(n,"__wbg_consolelog_c37e348eab7a6a4b",(function(){return r.b})),t.d(n,"__wbg_get_f099d98ea7d68360",(function(){return r.d})),t.d(n,"__wbg_length_450572e01ae27466",(function(){return r.f})),t.d(n,"__wbg_isArray_bccef1135dd559c1",(function(){return r.e})),t.d(n,"__wbg_get_0c6963cbab34fbb6",(function(){return r.c})),t.d(n,"__wbindgen_number_get",(function(){return r.n})),t.d(n,"__wbindgen_string_get",(function(){return r.p})),t.d(n,"__wbindgen_boolean_get",(function(){return r.i})),t.d(n,"__wbindgen_throw",(function(){return r.r})),t.d(n,"__wbindgen_memory",(function(){return r.m}))},24:function(e,n,t){"use strict";(function(e){t.d(n,"s",(function(){return z})),t.d(n,"t",(function(){return x})),t.d(n,"a",(function(){return A})),t.d(n,"o",(function(){return S})),t.d(n,"l",(function(){return j})),t.d(n,"k",(function(){return O})),t.d(n,"j",(function(){return I})),t.d(n,"h",(function(){return E})),t.d(n,"g",(function(){return N})),t.d(n,"q",(function(){return R})),t.d(n,"b",(function(){return C})),t.d(n,"d",(function(){return J})),t.d(n,"f",(function(){return P})),t.d(n,"e",(function(){return q})),t.d(n,"c",(function(){return D})),t.d(n,"n",(function(){return M})),t.d(n,"p",(function(){return W})),t.d(n,"i",(function(){return Z})),t.d(n,"r",(function(){return B})),t.d(n,"m",(function(){return F}));var r=t(27),i=t(28),o=t(29),a=t(25),s=new Array(32).fill(void 0);function l(e){return s[e]}s.push(void 0,null,!0,!1);var d=s.length;function u(e){var n=l(e);return function(e){e<36||(s[e]=d,d=e)}(e),n}var f=new("undefined"===typeof TextDecoder?(0,e.require)("util").TextDecoder:TextDecoder)("utf-8",{ignoreBOM:!0,fatal:!0});f.decode();var c=null;function b(){return null!==c&&c.buffer===a.i.buffer||(c=new Uint8Array(a.i.buffer)),c}function m(e,n){return f.decode(b().subarray(e,e+n))}function _(e){d===s.length&&s.push(s.length+1);var n=d;return d=s[n],s[n]=e,n}function h(e){return void 0===e||null===e}var p=null;var g=null;function y(){return null!==g&&g.buffer===a.i.buffer||(g=new Int32Array(a.i.buffer)),g}var v=0,w=new("undefined"===typeof TextEncoder?(0,e.require)("util").TextEncoder:TextEncoder)("utf-8"),k="function"===typeof w.encodeInto?function(e,n){return w.encodeInto(e,n)}:function(e,n){var t=w.encode(e);return n.set(t),{read:e.length,written:t.length}};function z(){try{var e=a.b(-16);a.g(e);var n,t=y()[e/4+0],r=y()[e/4+1];return 0!==t&&(n=(i=t,o=r,b().subarray(i/1,i/1+o)).slice(),a.d(t,1*r)),n}finally{a.b(16)}var i,o}function x(){return u(a.h())}var T,A=function(){function e(){Object(r.a)(this,e)}return Object(i.a)(e,[{key:"__destroy_into_raw",value:function(){var e=this.ptr;return this.ptr=0,e}},{key:"free",value:function(){var e=this.__destroy_into_raw();a.a(e)}}]),e}(),S=function(e){u(e)},j=function(e){return void 0===l(e)},O=function(e){return null===l(e)},I=function(e){return!l(e)},E=function(e,n,t,r){return _(Object(o.b)(m(e,n),m(t,r)))},N=function(e,n,t){Object(o.a)(m(e,n),t>>>0)},R=function(e,n){return _(m(e,n))},C=function(e,n){console.console_log(m(e,n))},J=function(e,n){return _(l(e)[n>>>0])},P=function(e){return l(e).length},q=function(e){return Array.isArray(l(e))},D=(T=function(e,n){return _(Reflect.get(l(e),l(n)))},function(){try{return T.apply(this,arguments)}catch(e){a.c(_(e))}}),M=function(e,n){var t=l(n),r="number"===typeof t?t:void 0;(null!==p&&p.buffer===a.i.buffer||(p=new Float64Array(a.i.buffer)),p)[e/8+1]=h(r)?0:r,y()[e/4+0]=!h(r)},W=function(e,n){var t=l(n),r="string"===typeof t?t:void 0,i=h(r)?0:function(e,n,t){if(void 0===t){var r=w.encode(e),i=n(r.length);return b().subarray(i,i+r.length).set(r),v=r.length,i}for(var o=e.length,a=n(o),s=b(),l=0;l<o;l++){var d=e.charCodeAt(l);if(d>127)break;s[a+l]=d}if(l!==o){0!==l&&(e=e.slice(l)),a=t(a,o,o=l+3*e.length);var u=b().subarray(a+l,a+o);l+=k(e,u).written}return v=l,a}(r,a.e,a.f),o=v;y()[e/4+1]=o,y()[e/4+0]=i},Z=function(e){var n=l(e);return"boolean"===typeof n?n?1:0:2},B=function(e,n){throw new Error(m(e,n))},F=function(){return _(a.i)}}).call(this,t(26)(e))},25:function(e,n,t){"use strict";var r=t.w[e.i];e.exports=r;t(24);r.j()},26:function(e,n){e.exports=function(e){if(!e.webpackPolyfill){var n=Object.create(e);n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),Object.defineProperty(n,"exports",{enumerable:!0}),n.webpackPolyfill=1}return n}},27:function(e,n,t){"use strict";function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}t.d(n,"a",(function(){return r}))},28:function(e,n,t){"use strict";function r(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function i(e,n,t){return n&&r(e.prototype,n),t&&r(e,t),e}t.d(n,"a",(function(){return i}))},29:function(e,n,t){"use strict";t.d(n,"a",(function(){return a})),t.d(n,"b",(function(){return s}));var r=t(9);var i=JSON.parse('\n{"std": {"folders": {"r": {"folders": {}, "files": {"wasi": {"fileName": "wasi", "fileId": 3, "isAsm": false, "code": "/// Wasi runtime\\nstandalone runtime module wasi\\n\\nuse core.str\\nuse core.mem\\n\\n// Tested on Wasmtime 0.15.0\\nfrom wasi_unstable import {\\n    pub fun fd_write(fd: i32, iovs: i32, iovs_len: i32, nwritten: i32): i32\\n}\\n\\n/// Print a string to stdout.\\npub fun print(message: str.Str) {\\n    let iov = mem.malloc(12)\\n    mem.set_i32(iov, message.start)\\n    mem.set_i32(iov + 4, message.len)\\n    fd_write(1, iov, 1, iov + 8)\\n    mem.free(iov)\\n}\\n"}, "r": {"fileName": "r", "fileId": 4, "isAsm": false, "code": "/// Runtime modules\\n///\\n/// This module hosts a collection of runtime modules for well known platforms, such as Wasi.\\nmodule r\\n\\n"}}}}, "files": {"std": {"fileName": "std", "fileId": 2, "isAsm": false, "code": "/// The Zephyr standard library\\nmodule std\\n\\n"}}}, "core": {"folders": {"mem": {"folders": {}, "files": {"utils": {"fileName": "utils", "fileId": 7, "isAsm": true, "code": "module mem\\n\\n/// Increases the memory size by a given number of pages and return the old\\n/// memory size, or -1 if the operation failed.\\n///\\n/// A memory page is 65536 bytes, or 64Ki bytes\\nfun memory_grow(size: i32): i32 {\\n    local.get size\\n    memory.grow\\n}\\n\\n/// Returns the size of memory in pages (65536 = 2^16 bytes).\\nfun memory_size(): i32 {\\n    memory.size\\n}\\n\\n/// Reads an i32 from memory, expects an alignment of 32 at least.\\npub fun read_i32(addr: i32): i32 {\\n    local.get addr\\n    i32.load 2 0\\n}\\n\\n/// Reads an u8 from memory, returned as an i32.\\npub fun read_u8(addr: i32): i32 {\\n    local.get addr\\n    i32.load8_u 0 0\\n}\\n\\n/// Set an i32 at the given memory address, expects an alignment of 32 at least.\\npub fun set_i32(addr: i32, val: i32) {\\n    local.get addr\\n    local.get val\\n    i32.store 2 0\\n}\\n\\npub fun set_u8(addr: i32, val: i32) {\\n    local.get addr\\n    local.get val\\n    i32.store8 0 0\\n}\\n"}, "malloc": {"fileName": "malloc", "fileId": 8, "isAsm": false, "code": "/// The malloc module handles memory management, it exposes a malloc and free\\n/// implementation.\\nmodule mem\\n\\nuse core.utils\\n\\n// The global memory allocator.\\n//\\n// Malloc is implemented using a doubly linked free list with a first fit\\n// strategy. Malloc always return a block with an aligment of 8 bytes.\\n// Coalescing is done after the free operation.\\n//\\n// Each block is composed of:\\n//   - a 4 bytes header\\n//   - a 4 bytes pointer to the next block\\n//   - a 4 bytes pointer to the previous block\\n//   - a 4 bytes footer\\n//\\n//   0      4      8      10        n-4     n\\n//\\n//   +------+------+------+----------+------+\\n//   |      |      |      |          |      |\\n//   |header| next | prev |   ....   |footer|\\n//   |      |      |      |          |      |\\n//   +------+------+------+----------+------+\\n//\\n//\\n// The header and the footer have the same values, they are outsize of the\\n// range seen by the user. The 31 lowest bits indicate the size, while the\\n// highest bit is a flag that is set when the block is allocated, and unset\\n// when it is freed.\\n// The size do not correspond to the size seen by the user, but to the number\\n// of bytes following the header (including the footer): the smallest valid\\n// valid takes 16 bytes in memory and thus has a size of 12 (16 - 4).\\n//\\n// Assumptions:\\n//   - The compiler ensures that at initialization read_i32(0) returns the\\n//     address of the first (and unique) free block.\\n//   - The compiler ensures that at initialization there is a fake\\n//     \'allocated block\' footer just before the first free block.\\n\\n/// Returns a fresh block of memory, guaranted with an alignment of at least 8.\\n///\\n/// This malloc implementation uses a single (doubly linked) free list with a\\n/// first-fit strategy.\\n/// Coalescence is done when blocks are freed.\\npub fun malloc(size: i32): i32 {\\n    let addr = read_i32(0)\\n    let target_size = get_real_block_size(size)\\n    while true {\\n        if addr == 0 {\\n            // TODO: out of memory\\n            utils.panic()\\n        }\\n        if read_i32(addr) >= target_size {\\n            let block_size = split_block(addr, target_size)\\n            remove_block(addr)\\n            let header = block_size | 0x80000000 // set the allocated bit\\n            set_i32(addr, header)                // header\\n            set_i32(addr + block_size, header)   // footer\\n            return addr + 4\\n        }\\n        addr = read_i32(addr + 4)                // go to next block\\n    }\\n    // needed for wasm stack type check...\\n    // TODO: find a (compiler) solution\\n    return 0\\n}\\n\\n/// Marks the memory as free.\\n///\\n/// This operation is the inverse of malloc, blocks freed can be re-allocated later.\\npub fun free(ptr: i32) {\\n    let addr = ptr - 4\\n    let old_root = read_i32(0)\\n    if old_root != 0 {\\n        set_i32(old_root + 8, addr)\\n    }\\n    set_i32(0, addr)\\n    set_i32(addr + 4, old_root)\\n    set_i32(addr + 8, 0)\\n    // Mark the block as free\\n    let header = read_i32(addr) ^ 0x80000000 // unset the allocated bit\\n    set_i32(addr, header)                    // header\\n    set_i32(addr + header, header)           // footer\\n    try_coalesce(addr)\\n}\\n\\n/// Computes the final size of a block, so that the next block is aligned to 8 and\\n/// there is room for at least two 4 bytes pointers and a 4 bytes footer.\\nfun get_real_block_size(size: i32): i32 {\\n    if size <= 8 {\\n        return 12\\n    }\\n    let body_size = (size + 0b111) & -0b1000\\n    return body_size + 4\\n}\\n\\n/// Tell if a block is free given its header.\\n///\\n/// A block header is composed of 31 bits for its size, while the highest bit\\n/// is a flag indicating if the block is free (0) or allocated (1).\\n/// Thus, interpreted as a signed 32 bits integer, if the header is positive\\n/// then the block is free.\\nfun is_free(header: i32): bool {\\n    return header >= 0\\n}\\n\\n/// Split a free block, if possible, and return the new size.\\n///\\n/// The minimal block size is 16:\\n///   - 4 bytes header\\n///   - 4 bytes next pointer\\n///   - 4 bytes prev pointer\\n///   - 4 bytes footer\\n///\\n/// ! The block is assumed to be free.\\nfun split_block(addr: i32, size: i32): i32 {\\n    let available_size = read_i32(addr)\\n    if available_size - size >= 16 {\\n        let new_block_addr = addr + 4 + size\\n        // update pointers\\n        set_i32(new_block_addr + 8, addr)               // prev points to addr\\n        set_i32(new_block_addr + 4, read_i32(addr + 4)) // next points to block.next\\n        set_i32(addr + 4, new_block_addr)               // block.next points to new_block\\n        // update sizes\\n        set_i32(addr, size)\\n        set_i32(new_block_addr, available_size - size - 4)\\n        return size\\n    }\\n    return available_size\\n}\\n\\n/// Removes a block from the free list.\\nfun remove_block(addr: i32) {\\n    let next = read_i32(addr + 4)\\n    let prev = read_i32(addr + 8)\\n    if next != 0 {\\n        set_i32(next + 8, prev)\\n    }\\n    if prev != 0 {\\n        set_i32(prev + 4, next)\\n    } else {\\n        set_i32(0, next)\\n    }\\n}\\n\\n/// Try to coalesce a block with the next one (following to memory layout) and\\n/// the one just before.\\n///\\n/// ! The block passed as argument is assumed to be free.\\nfun try_coalesce(addr: i32) {\\n    let size = read_i32(addr)\\n    let next_addr = addr + 4 + size\\n    if next_addr < memory_size() * 0x10000 { // end of memory\\n        let next_header = read_i32(next_addr)\\n        if is_free(next_header) {\\n            // if the block is free, the header corresponds to its size\\n            size = size + 4 + next_header\\n            remove_block(next_addr)\\n            set_i32(addr, size)        // header\\n            set_i32(addr + size, size) // footer\\n        }\\n    }\\n    let prev_footer = read_i32(addr - 4)\\n    if is_free(prev_footer) {\\n        size = size + 4 + prev_footer\\n        let prev_addr = addr - prev_footer - 4\\n        remove_block(addr)\\n        set_i32(prev_addr, size)        // header\\n        set_i32(prev_addr + size, size) // footer\\n    }\\n}\\n\\n"}}}, "str": {"folders": {}, "files": {"str": {"fileName": "str", "fileId": 9, "isAsm": false, "code": "/// Implementation of strings for Zephyr.\\nmodule str\\n\\nuse core.mem\\n\\n/// A String object, composed of a buffer holding the data and a len.\\npub struct String {\\n    len: i32,\\n    capacity: i32,\\n    buffer: i32,\\n}\\n\\n/// A String slice, a structure that doesn\'t own the data it points to.\\npub struct Str {\\n    len: i32,\\n    start: i32,\\n}\\n\\n/// Creates a new string.\\npub fun new_string(): String {\\n    let capacity = 12 // Arbitrary default size\\n    let buffer = mem.malloc(capacity)\\n    return String {\\n        len: 0,\\n        capacity: capacity,\\n        buffer: buffer,\\n    }\\n}\\n\\n/// Adds a character to the string.\\npub fun push_char(s: String, char: i32) {\\n    if s.capacity <= s.len {\\n        // Reallocate the buffer\\n        let new_capacity = s.capacity * 2\\n        let new_buffer = mem.malloc(new_capacity)\\n        let old_buffer = s.buffer\\n        let idx = 0\\n        while idx < s.len {\\n            let tmp = mem.read_u8(old_buffer + idx)\\n            mem.set_u8(new_buffer + idx, tmp)\\n            idx = idx + 1\\n        }\\n        mem.free(s.buffer)\\n        s.buffer = new_buffer\\n        s.capacity = new_capacity\\n    }\\n    mem.set_u8(s.buffer + s.len, char)\\n    s.len = s.len + 1\\n}\\n\\n/// Return slice from a String.\\npub fun as_str(string: String): Str {\\n    return Str {\\n        len: string.len,\\n        start: string.buffer,\\n    }\\n}\\n\\n"}}}}, "files": {"utils": {"fileName": "utils", "fileId": 5, "isAsm": true, "code": "/// Exposes utility functions\\nstandalone module utils\\n\\npub fun panic() {\\n    unreachable\\n}\\n"}, "core": {"fileName": "core", "fileId": 6, "isAsm": false, "code": "/// Core is module exposing the runtime functionnalities of Zephyr, it is\\n/// known from the compiler.\\nmodule core\\n\\nuse core.mem\\nuse core.utils\\n\\n"}}}}'),o=t(7);function a(e,n){if(o.d){var t=o.a.output;switch(n){case o.a.input:t=o.a.input;break;case o.a.error:t=o.a.error}Object(o.d)(e,t)}}function s(e,n){if("playground"===e&&"main"===n)return{files:[{code:o.b,fileName:"main",fileId:1,isAsm:!1}],isStandalone:!1};var t=n.split("/"),a=t.pop();if(void 0!==a){var s=i[e];if(s){var l,d=function(e,n){var t;if("undefined"===typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(t=Object(r.a)(e))||n&&e&&"number"===typeof e.length){t&&(e=t);var i=0,o=function(){};return{s:o,n:function(){return i>=e.length?{done:!0}:{done:!1,value:e[i++]}},e:function(e){throw e},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,s=!0,l=!1;return{s:function(){t=e[Symbol.iterator]()},n:function(){var e=t.next();return s=e.done,e},e:function(e){l=!0,a=e},f:function(){try{s||null==t.return||t.return()}finally{if(l)throw a}}}}(t);try{for(d.s();!(l=d.n()).done;){var u=l.value;s=s.folders[u]}}catch(h){d.e(h)}finally{d.f()}var f=[],c=!1;if(void 0!==s.files[a])f.push(s.files[a]),c=!0;else{void 0===(s=s.folders[a])&&console.log("Error: last module does not exist - JS size");for(var b=0,m=Object.keys(s.files);b<m.length;b++){var _=m[b];f.push(s.files[_])}}return{files:f,isStandalone:c}}console.log("Error: module does not exist - JS side")}else console.log("Error: error in module resolution - JS side")}}}]);
//# sourceMappingURL=3.8db591f1.chunk.js.map